#include "RPC.h"

GRPC_t::GRPC_t(Lobby_t& Lobby) :
RPC_i(Lobby)
{
}

GRPC_t::~GRPC_t()
{
}

RPC_i::RPC_i(Lobby_t& Lobby) :
m_Lobby(Lobby)
{

}

WAMP_t::WAMP_t(Lobby_t& Lobby) :
RPC_i(Lobby)
{
}

WAMP_t::~WAMP_t()
{
}

/*! \brief Add a new user to the lobby.
 * 
 *  Schedules a work item that makes the lobby add a new user.
 *  This is a blocking call that will return when the user was added or the lobby
 *  failed to add the new user.
 * 
 *  \param UserName The name of the user that should be added
 * 
 *  \return OK if user added, failure if user not added.
 * 
 */
Core::WorkOrderResult_t RPC_i::AddUserImpl(std::string const& UserName)
{
  return m_Lobby.AddUser(UserName).get();
}

/*! \brief Google RPC wrapper for AddUserImpl.
 * 
 *  Decodes the received message using the GRPC framework and then calls 'AddUserImpl'.
 * 
 *  \param Context Not used
 *  \param User User to be added in protocol buffer format (see .proto file)
 *  \param Response Response to be sent back to client. Not applicable for this RPC.
 * 
 *  \return OK if user added, failure if user not added.
 * 
 */
::grpc::Status GRPC_t::AddUser(::grpc::ServerContext *Context, const ::comm::User *User, ::google::protobuf::Empty *Response)
{
  //Core::WorkOrderResult_t Result = AddUserImpl(UserName);
  return ::grpc::Status(grpc::StatusCode::ALREADY_EXISTS, "OOPS MY CD JUST SKIPPED");
}

/*! \brief Start the google RPC server on both interfaces.
 * 
 *  The RPC server will listen on the combination Ip+Port. If multiple NICs/IPs
 *  are available the Ip param may be relevant but if hosting the server on lo
 *  this should be 0.0.0.0.
 * 
 *  \param Ip Ip onto which to listen for incoming RPC's; This will probably be 0.0.0.0 if localhost.
 *  \param Port Port onto which to listen for incoming RPC's.
 * 
 * 
 */
void GRPC_t::StartListeningOnInterface(std::string&& Ip, uint16_t Port)
{
  // Listen on the given address without any authentication mechanism.
  auto ServerBuilder = ::grpc::ServerBuilder();
  ServerBuilder.AddListeningPort(Ip+":"+std::to_string(Port), grpc::InsecureServerCredentials());
  // Register "service" as the instance through which we'll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  ServerBuilder.RegisterService(this);
  // Finally assemble the server.
  auto server = std::unique_ptr<::grpc::Server>(ServerBuilder.BuildAndStart());

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  server->Wait();
}

void WAMP_t::AddUser(autobahn::wamp_invocation invocation)
{
  std::cout << "Got to add an user"<<std::endl;
}

/*! \brief Connect to the WAMP server
 * 
 *  Connect to the WAMP router and register all remote procedure calls that
 *  clients may call.
 * 
 *  \param Ip Ip onto which to listen for incoming RPC's; Probably 127.0.0.1.
 *  \param Port Port onto which to listen for incoming RPC's.
 * 
 * 
 */
void WAMP_t::StartListeningOnInterface(std::string&& Ip, uint16_t Port)
{

  try
  {
    // ASIO service object
    //
    boost::asio::io_service io;


    const std::string realm = "realm1";
    bool debug = false;
    const boost::asio::ip::tcp::endpoint endpoint = boost::asio::ip::tcp::endpoint(boost::asio::ip::address::from_string(Ip), Port);
    auto transport = std::make_shared<autobahn::wamp_tcp_transport>(io, endpoint, debug);
    auto session = std::make_shared<autobahn::wamp_session>(io, debug);
    transport->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session));

    // Make sure the continuation futures we use do not run out of scope prematurely.
    // Since we are only using one thread here this can cause the io service to block
    // as a future generated by a continuation will block waiting for its promise to be
    // fulfilled when it goes out of scope. This would prevent the session from receiving
    // responses from the router.
    boost::future<void> connect_future;
    boost::future<void> start_future;
    boost::future<void> join_future;
    boost::future<void> provide_future_add;
    boost::future<void> provide_future_longop;

    connect_future = transport->connect().then([&](boost::future<void> connected)
    {
      try
      {
        connected.get();
      } catch (const std::exception& e)
      {
        std::cerr << e.what() << std::endl;
        io.stop();
        return;
      }

      std::cerr << "transport connected" << std::endl;

      start_future = session->start().then([&](boost::future<void> started)
      {
        try
        {
          started.get();
        } catch (const std::exception& e)
        {
          std::cerr << e.what() << std::endl;
          io.stop();
          return;
        }

        std::cerr << "session started" << std::endl;

        join_future = session->join(realm).then([&](boost::future<uint64_t> joined)
        {
          try
          {
            std::cerr << "joined realm: " << joined.get() << std::endl;
          } catch (const std::exception& e)
          {
            std::cerr << e.what() << std::endl;
            io.stop();
            return;
          }

          provide_future_add = session->provide("com.server.adduser", [&](autobahn::wamp_invocation e)
          {
            this->AddUser(e);
          }).then(
            [&](boost::future<autobahn::wamp_registration> registration)
            {
              try
              {
                std::cerr << "registered procedure:" << registration.get().id() << std::endl;
              } catch (const std::exception& e)
              {
                std::cerr << e.what() << std::endl;
                io.stop();
                return;
              }
            });
        });
      });
    });

    std::cerr << "starting io service" << std::endl;
    io.run();
    std::cerr << "stopped io service" << std::endl;
  } catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }
}
//          // start the WAMP session on the transport that has been connected
//          //
//          start_future = session->start().then([&](boost::future<bool> started)
//          {
//            if (started.get())
//            {
//              std::cerr << "session started" << std::endl;
//
//              // join a realm with the WAMP session
//              //
//              join_future = session->join(realm).then([&](boost::future<uint64_t> s)
//              {
//                std::cerr << "joined realm: " << s.get() << std::endl;
//
//                // SUBSCRIBE to a topic and receive events
//                //
//                session->subscribe("com.example.onhello",
//                  [](const autobahn::wamp_event & event)
//                  {
//                    std::cerr << "event for 'onhello' received: " << event.argument<std::string>(0) << std::endl;
//                  }
//                );
//
//                // REGISTER a procedure for remote calling
//                //
//                session->provide("com.example.add2", &add2);
//              } catch (std::exception& e)
//              {
//                std::cerr << e.what() << std::endl;
//              }
//
//            }